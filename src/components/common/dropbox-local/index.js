import React, { Component } from 'react';
import { ReactComponent as AddImageIcon } from 'assets/svg/AddImage.svg';
import { ReactComponent as PlusIcon } from 'assets/svg/plus_circle.svg';
import { autoGenerateDownloadLinkWithBlob } from 'utils';
import './style.scss';
import { toast } from 'react-toastify';
import prettySize from 'prettysize';

import { getSysConfigurations } from 'services/file-operation';

// const docxMineType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';

class DropBox extends Component {
  constructor(props) {
    super(props);
    this.state = {
      accept: props.accept || null,
      maxSingleFileSize: 0,
      // maxGroupFileSize: 0,
      // encryptionRequired: false,
      fileList: [],
      isConfigLoaded: false,
      networkDisabled: false,
      networkErrors: [],
    };
    this.dropRef = React.createRef();
  }

  componentDidMount() {
    const div = this.dropRef.current;
    div.addEventListener('dragenter', this.handleDragIn);
    div.addEventListener('dragleave', this.handleDragOut);
    div.addEventListener('dragover', this.handleDrag);
    div.addEventListener('drop', this.handleDrop);

    this.getFileSysConfigurations();
  }

  componentWillUnmount() {
    this.isComponentUnmounting = true;
    const div = this.dropRef.current;
    div.removeEventListener('dragenter', this.handleDragIn);
    div.removeEventListener('dragleave', this.handleDragOut);
    div.removeEventListener('dragover', this.handleDrag);
    div.removeEventListener('drop', this.handleDrop);
  }

  handleDrag = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };

  handleDragIn = (e) => {
    e.preventDefault();
    e.stopPropagation();
    // if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {
    // }
  };

  handleDragOut = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };

  handleDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    this.onChangeFiles(e?.dataTransfer?.files);
    e.target.value = null;
    e.dataTransfer.clearData();
  };

  handleChangeFiles = (e) => {
    e.preventDefault();
    e.stopPropagation();
    this.onChangeFiles(e.target?.files);
    e.target.value = null;
  };

  onChangeFiles = (files) => {
    const { onChange } = this.props;
    const { accept, maxSingleFileSize } = this.state;
    if (files && files.length > 0) {
      if (files.length > 1) {
        toast.error('The maximum file allowed is 1');
      } else {
        const file = files[0];
        if (!accept.includes(file?.name.split('.').pop())) {
          toast.error(`Invalid file type. The acceptable file types are: ${accept}.`);
          return;
        }
        if (!file.name.match(/^[\w\s-]+\.[A-Za-z]{3,}$/g)) {
          toast.error(`${file.name}: File name cannot contains special characters.`);
          return;
        }
        if (file.size > maxSingleFileSize) {
          toast.error(`Uploaded content have exceeded the maximum size. Maximum single file size allowed: ${prettySize(maxSingleFileSize)}.`);
          return;
        }
        if (onChange) onChange(file);
        this.setState({ fileList: Array.from(files) });
      }
    }
  };

  getFileSysConfigurations = async () => {
    const { submissionType } = this.props;
    const { status, data } = await getSysConfigurations({
      submissionType,
    });

    let result = {
      networkDisabled: true,
      networkErrors: data.errorMessage || [String(`HTTP code ${status}`)],
      isConfigLoaded: true,
    };
    if (status === 200 && data.status === 'Pass') {
      let accept = '';
      data.allowedFileTypes.forEach((item, index) => {
        const addOn = index === data.allowedFileTypes.length - 1 ? `.${item}` : `.${item}, `;
        accept += addOn;
      });
      result = {
        accept,
        maxSingleFileSize: parseFloat(data.maxSingleFileSize),
        maxGroupFileSize: parseFloat(data.maxGroupFileSize),
        isConfigLoaded: true,
        submissionId: data.submissionId,
        encryptionRequired: data.encryptionRequired,
      };
    }
    if (!this.isComponentUnmounting) this.setState(result);
  };

  getFileList = () => {
    const { fileList } = this.state;
    return fileList;
  };

  onDeleteFile = async (index) => {
    const { onChange } = this.props;
    const { fileList } = this.state;
    const temp = fileList;
    temp.splice(index, 1);
    if (onChange) onChange(temp);
    if (!this.isComponentUnmounting) this.setState({ fileList: temp });
  };

  render() {
    const { fileList, networkDisabled, networkErrors, accept, isConfigLoaded } = this.state;
    const { disabled, size, name, error, multiple } = this.props;
    return (
      <div>
        <div className={`upload-drop-zone upload-drop-zone-${size} ${error ? 'form-error' : ''}`} id="drop-zone" ref={this.dropRef}>
          <AddImageIcon className="mb-4 d-desktop-only" alt="" />
          {isConfigLoaded &&
            (networkDisabled ? (
              <div className="text-center">
                <span className="d-desktop-only">File upload is disabled due to network error:</span>
                {networkErrors.map((error, eIndex) => (
                  <span className="d-desktop-only" key={`network_error_${eIndex + 1}`}>
                    {error}
                  </span>
                ))}
              </div>
            ) : (
              <div className="d-flex drag-drop-text justify-content-center">
                <span className="d-desktop-only">Drag & Drop or</span>
                <PlusIcon className="plus-icon d-ipad-only d-mobile-only" />
                <div className="form-group">
                  <input className="m-0" type="file" name={name} multiple={multiple} disabled={disabled || false} id="js-upload-files" accept={accept || 'image/*'} onChange={this.handleChangeFiles} />
                  <label htmlFor="js-upload-files" className="font-bold browse d-desktop-only">
                    Browse
                  </label>
                  <span className="font-bold browse d-ipad-only d-mobile-only">
                    Upload document
                    <span className="text-black">({accept})</span>
                  </span>
                </div>
                <span className="d-desktop-only">files to upload</span>
              </div>
            ))}
          {!isConfigLoaded && (
            <div className="text-center">
              <span className="d-desktop-only">Loading System Configuration...</span>
            </div>
          )}
        </div>
        <div className="upload-drop-zone__file mt-4 mb-4">
          <ul className="">
            {fileList &&
              fileList.map((file, index) => (
                <li className="" id="" key={`image_upload__${index + 1}`}>
                  <span
                    className="cursor-pointer"
                    onClick={() => {
                      autoGenerateDownloadLinkWithBlob(file.name, new Blob([file]));
                    }}>
                    {`${index + 1}. ${file.name}`}
                  </span>
                  <div className="remove-button" onClick={() => this.onDeleteFile(index)} />
                </li>
              ))}
          </ul>
        </div>
      </div>
    );
  }
}

export default DropBox;
